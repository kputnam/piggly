module Piggly

  module HtmlTag
    unless defined? HTML_REPLACE
      HTML_REPLACE = { '&' => '&amp;', '"' => '&quot;', '>' => '&gt;', '<' => '&lt;' }
      HTML_PATTERN = /[&"<>]/
    end

    def html(output = '')
      begin
        @htmltag_output, htmltag_output = output, @htmltag_output

        # TODO: doctype
        yield
      ensure
        # restore
        @htmltag_output = htmltag_output
      end
    end

    def tag(name, content = nil, attributes = {})
      if content.is_a?(Hash) and attributes.empty?
        content, attributes = nil, content
      end

      attributes = attributes.inject('') do |string, pair|
        k, v = pair
        string << %[ #{k}="#{v}"]
      end


      if content.nil?
        if block_given?
          @htmltag_output << "<#{name}#{attributes}>"
          yield
          @htmltag_output << "</#{name}>"
        else
          @htmltag_output << "<#{name}#{attributes}/>"
        end
      else
        @htmltag_output << "<#{name}#{attributes}>#{content.to_s}</#{name}>"
      end
    end

    if ''.respond_to?(:fast_xs)
      def e(string)
        e.fast_xs
      end
    elsif ''.respond_to?(:to_xs)
      def e(string)
        e.to_xs
      end
    else
      def e(string)
        string.gsub(HTML_PATTERN) {|c| HTML_REPLACE[c] }
      end
    end
  end

  class HtmlReporter < Reporter
    extend HtmlTag

    def self.output(path, data, summary)
      File.open(report_path(path, '.html'), 'w') do |f|
        html(f) do

          tag :html, :xmlns => 'http://www.w3.org/1999/xhtml' do
            tag :head do
              tag :title, "Code Coverage: #{File.basename(path)}"
              tag :link, :rel => 'stylesheet', :type => 'text/css', :href => 'piggly.css'
            end

            tag :body do
              table(path)

              tag :br
              tag :div, :class => 'listing' do
                tag :table do
                  tag :tr do
                    tag :td, data.fetch('lines').to_a.map{|n| %[<a href="#L#{n}" id="L#{n}">#{n}</a>] }.join("\n"), :class => 'lines'
                    tag :td, data.fetch('html'), :class => 'code'
                  end
                end
              end

              toc(data.fetch('tags'))
            end
          end

        end
      end
    end

    def self.toc(tags)
      todo = tags.reject{|t| t.complete? }
      
      tag :div, :class => 'toc' do
        tag :a, 'Index', :href => 'index.html'

        unless todo.empty?
          tag :ol do
            todo.each do |t|
              tag(:li, :class => t.type) { tag :a, t.description, :href => "#T#{t.id}" }
            end
          end
        end
      end
    end

    def self.timestamp
      tag :div, "Generated by piggly #{Piggly::VERSION} at #{Time.now.strftime('%B %d, %Y %H:%M %Z')}", :class => 'timestamp'
    end

    def self.table(*files)
      tag :table, :class => 'summary sortable' do
        tag :tr do
          tag :th, 'File'
          tag :th, 'Blocks'
          tag :th, 'Loops'
          tag :th, 'Branches'
          tag :th, 'Block Coverage'
          tag :th, 'Loop Coverage'
          tag :th, 'Branch Coverage'
        end

        files.each_with_index do |name, index|
          summary = Profile.summary(name)
          row     = index.modulo(2) == 0 ? 'even' : 'odd'

          tag :tr, :class => row do
            unless summary.include?(:block) or summary.include?(:loop) or summary.include?(:branch)
              # PigglyParser couldn't parse this file
              tag :td, File.basename(name), :class => 'file fail'
              tag(:td, :class => 'count') { tag :span, -1, :style => 'display:none' }
              tag(:td, :class => 'count') { tag :span, -1, :style => 'display:none' }
              tag(:td, :class => 'count') { tag :span, -1, :style => 'display:none' }
              tag(:td, :class => 'pct') { tag :span, -1, :style => 'display:none' }
              tag(:td, :class => 'pct') { tag :span, -1, :style => 'display:none' }
              tag(:td, :class => 'pct') { tag :span, -1, :style => 'display:none' }
            else
              tag(:td, :class => 'file') { tag :a, File.basename(name), :href => File.basename(name, '.*') + '.html' }
              tag :td, (summary[:block][:count]  || 0), :class => 'count'
              tag :td, (summary[:loop][:count]   || 0), :class => 'count'
              tag :td, (summary[:branch][:count] || 0), :class => 'count'
              tag(:td, :class => 'pct') { percent(summary[:block][:percent])  }
              tag(:td, :class => 'pct') { percent(summary[:loop][:percent])   }
              tag(:td, :class => 'pct') { percent(summary[:branch][:percent]) }
            end
          end

        end
      end
    end

    def self.percent(pct)
      if pct
        tag :table, :align => 'center' do
          tag :tr do

            tag :td, '%0.2f%%&nbsp;' % pct, :class => 'num'
            tag :td, :class => 'graph' do
              if pct
                tag :table, :align => 'right', :class => 'graph' do
                  tag :tr do
                    tag :td, :class => 'covered', :width => (pct/2.0).to_i
                    tag :td, :class => 'uncovered', :width => ((100-pct)/2.0).to_i
                  end
                end
              end
            end

          end
        end
      else
        tag :span, -1, :style => 'display:none'
      end
    end

    class Index < HtmlReporter
      extend HtmlTag

      def self.output(sources)
        File.open(File.join(report_path, 'index.html'), 'w') do |f|
          html(f) do

            tag :html do
              tag :head do
                tag :title, 'PL/PgSQL Code Coverage'
                tag :link, :rel => 'stylesheet', :type => 'text/css', :href => 'piggly.css'
                tag :script, '<!-- -->', :type => 'text/javascript', :src => 'sortable.js'
              end

              tag :body do
                table(*sources.sort)

                tag :br
                timestamp
              end
            end

          end
        end
      end
    end

  end
end
