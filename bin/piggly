#!/usr/bin/env ruby
require 'optparse'
require 'rubygems'
$:.push File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib'))
require 'piggly'

# Number of children to fork for parallel tasks
Piggly::Util::ProcessQueue.children = 2

STDOUT.sync = true

module Piggly
  module Command
    class << self

      def main
        benchmark do
          tests = parse_options
          load_tests(tests)
          connect_to_database

          procedures = dump_procedures

          begin
            trace(procedures)
            clear_coverage
            execute_tests
            store_coverage
          ensure
            untrace(procedures)
          end

          create_index(procedures)
          create_reports(procedures)
          exit! 0 # avoid running tests again
        end
      end

    private

      def benchmark
        start = Time.now
        yield.tap do
          puts " > Completed in #{'%0.2f' % (Time.now - start)} seconds"
        end
      end

      def parse_options
        opts = OptionParser.new do |opts|
          opts.on("-I", "--include PATHS", "Prepend paths to $: (colon separated list)") do |paths|
            $:.concat paths.split(':')
          end

          opts.on("-o", "--output PATH", "Report output directory") do |dir|
            Piggly::Config.report_root = dir
          end

          opts.on("-c", "--cache-root PATH", "Compiler cache directory") do |dir|
            Piggly::Config.cache_root = dir
          end
          
          opts.on("-a", "--aggregate", "Aggregate data from the previous run") do
            Piggly::Config.aggregate = true
          end

          opts.on("--version", "Show version") do
            puts "piggly #{Piggly::VERSION::STRING} #{Piggly::VERSION::RELEASE_DATE}"
            exit
          end

          opts.on("-h", "--help", "Show this message") do
            puts opts
            exit 0
          end
        end

        if index = ARGV.index('--')
          extra = ARGV.slice!(index..-1).slice(1..-1)
        else
          extra = []
        end

        begin
          opts.parse! ARGV
          raise OptionParser::MissingArgument, "no tests specified" if ARGV.empty?
        rescue OptionParser::InvalidOption,
               OptionParser::InvalidArgument,
               OptionParser::MissingArgument
          puts opts
          puts
          puts $!.message
          exit -1
        end

        test_paths = ARGV.map{|p| Dir[p] }.flatten.sort
        ARGV.clear

        test_paths
      end

      def load_tests(tests)
        puts "Loading #{tests.size} test files"

        benchmark { tests.each{|file| load file } }
      end

      def connect_to_database
        ActiveRecord::Base.connection.active?
      rescue
        ActiveRecord::Base.establish_connection
      end

      def dump_procedures
        index = Piggly::Dumper::Index.instance
        index.update(Piggly::Dumper::Procedure.all)
        index.procedures
      end

      def trace(procedures)
        puts "Installing #{procedures.size} procedures"

        benchmark do
          procedures.each do |p|
            begin
              Piggly::Installer.trace(p)
            rescue Piggly::Parser::Failure
              puts $!
            end
          end
          Piggly::Installer.install_trace_support
        end
      end

      def clear_coverage
      # unless Piggly::Config.aggregate
      #   puts "Clearing previous run's profile"
      #   benchmark { Piggly::Profile.clear }
      # end
      end

      def execute_tests
        if defined?  Test::Unit::AutoRunner
          Test::Unit::AutoRunner.run
        elsif defined? Spec::Runner
          Spec::Runner.run
        else
          raise "Neither RSpec nor Test::Unit were detected"
        end
      end

      def store_coverage
      # puts "Storing coverage profile"
      # benchmark { Piggly::Profile.store }
      end

      def untrace(procedures)
        puts "Restoring #{procedures.size} procedures"
        benchmark do
          procedures.each{|p| Piggly::Installer.untrace(p) }
          Piggly::Installer.uninstall_trace_support
        end
      end

      def create_index(procedures)
        puts "Creating index"
        benchmark do
          Piggly::Reporter.install('piggly.css', 'sortable.js')
          Piggly::Reporter::Html::Index.output(procedures)
        end
      end

      def create_reports(procedures)
        puts "Creating reports"
        summary = Hash.new{|h,k| h[k] = Hash.new[:count => 0, :percent => 0]}

        benchmark do
          for procedure in procedures
            if result = Piggly::Compiler::Report.compile(procedure, Piggly::Profile.instance)
              Piggly::Reporter::Html.output(procedure, result[:html], result[:lines])
            end
          end
        end
      end

    end
  end
end

if __FILE__ == $0
  Piggly::Command.main
end
