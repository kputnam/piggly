#!/usr/bin/env ruby
require 'optparse'
require 'rubygems'
$:.push File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib'))
require 'piggly'

# Number of children to fork for parallel tasks
Piggly::Util::ProcessQueue.children = 2

STDOUT.sync = true

module Piggly
  module Command
    class << self

      def main
        benchmark do
          sources, tests = parse_options
          load_tests(tests)
          connect_to_database
          compile_procs(sources)
          install_procs(sources)
          clear_coverage
          execute_tests
          store_coverage
          uninstall_procs(sources)
          create_index(sources)
          create_reports(sources)
          exit! 0 # avoid running tests again
        end
      end

    private

      def benchmark
        start = Time.now
        yield
        puts " > Completed in #{'%0.2f' % (Time.now - start)} seconds"
      end

      def parse_options
        proc_paths = []

        opts = OptionParser.new do |opts|
          opts.on("-I", "--include PATHS", "Prepend paths to $: (colon separated list)") do |paths|
            $:.concat paths.split(':')
          end

          opts.on("-o", "--output PATH", "Report output directory") do |dir|
            Piggly::Config.report_root = dir
          end

          opts.on("-c", "--cache-root PATH", "Compiler cache directory") do |dir|
            Piggly::Config.cache_root = dir
          end

          opts.on("-s", "--proc-files PATH", "Stored procedures file list (may be specified many times)") do |dir|
            proc_paths << dir
          end

        # opts.on("-T", "--trace-prefix PATH", "Trace prefix") do |str|
        #   Piggly::Config.trace_prefix = str
        # end
          
          opts.on("-a", "--aggregate", "Aggregate data from the previous run") do
            Piggly::Config.aggregate = true
          end

          opts.on("--version", "Show version") do
            puts "piggly #{Piggly::VERSION::STRING} #{Piggly::VERSION::RELEASE_DATE}"
            exit
          end

          opts.on("-h", "--help", "Show this message") do
            puts opts
            exit 0
          end
        end

        if index = ARGV.index('--')
          extra = ARGV.slice!(index..-1).slice(1..-1)
        else
          extra = []
        end

        begin
          opts.parse! ARGV
          raise OptionParser::MissingArgument, "no tests specified" if ARGV.empty?
        rescue OptionParser::InvalidOption, OptionParser::InvalidArgument, OptionParser::MissingArgument
          puts opts
          puts
          puts $!.message
          exit -1
        end

        proc_paths = proc_paths.map{|p| Dir[p] }.flatten.sort
        test_paths = ARGV.map{|p| Dir[p] }.flatten.sort

        ARGV.clear

        return proc_paths, test_paths
      end

      def load_tests(tests)
        puts "Loading #{tests.size} test files"

        benchmark { tests.each{|file| load file } }

      # # TODO: this doesn't seem right, but workaround RSpec executing each spec twice
      # if defined? Spec::Runner::ExampleGroupRunner
      #   Spec::Runner::ExampleGroupRunner.send(:define_method, :load_files) do |*args|
      #     # don't do anything, we already loaded the files
      #   end
      # end
      end

      def connect_to_database
        ActiveRecord::Base.connection.active?
      rescue
        ActiveRecord::Base.establish_connection
      end

      def compile_procs(sources)
        stale = sources.select{|f| Piggly::TraceCompiler.stale?(f) }

        # build the parser if needed
        Piggly::Parser.parser

        puts "Compiling #{stale.size} files"
        benchmark do
          stale.each do |file|
            Piggly::Util::ProcessQueue.child do
              begin
                Piggly::TraceCompiler.cache(file)
            # rescue Errno::ENOENT, Piggly::Parser::Failure
            #   puts "! #{File.basename file}"
              rescue
                puts
                puts "#{$!.class}: #{$!.message}"
                puts $!.backtrace.join("\n")
              end
            end
          end
          Piggly::Util::ProcessQueue.start
        end
      end

      def install_procs(sources)
        puts "Installing #{sources.size} proc files"

        benchmark do
          sources.each do |file|
            begin
              Piggly::Installer.trace_proc(file)
            rescue Errno::ENOENT, Piggly::Parser::Failure
            # puts "! #{File.basename file}"
            rescue
              puts
              puts "#{$!.class}: #{$!.message}"
              puts $!.backtrace.join("\n")
            end
          end

          Piggly::Installer.install_trace
        end
      end

      def clear_coverage
        unless Piggly::Config.aggregate
          puts "Clearing previous run's profile"
          benchmark { Piggly::Profile.clear }
        end
      end

      def execute_tests
        if defined?  Test::Unit::AutoRunner
          Test::Unit::AutoRunner.run
        elsif defined? Spec::Runner
          Spec::Runner.run
        else
          raise "Neither RSpec nor Test::Unit were detected"
        end
      end

      def store_coverage
        puts "Storing coverage profile"
        benchmark { Piggly::Profile.store }
      end

      def uninstall_procs(sources)
        puts "Removing trace code"
        benchmark do
          sources.each do |file|
            begin
              Piggly::Installer.untrace_proc(file)
            rescue Errno::ENOENT, Piggly::Parser::Failure
            # puts "! #{File.basename file}"
            rescue
              puts
              puts "#{$!.class}: #{$!.message}"
              puts $!.backtrace.join("\n")
            end
          end

          Piggly::Installer.uninstall_trace
        end
      end

      def create_index(sources)
        puts "Creating index"
        benchmark do
          Piggly::Reporter.install('piggly.css', 'sortable.js')
          Piggly::HtmlReporter::Index.output(sources)
        end
      end

      def create_reports(sources)
        puts "Creating reports"
        summary = Hash.new{|h,k| h[k] = Hash.new[:count => 0, :percent => 0]}

        benchmark do
          sources.each do |file|
            Piggly::Util::ProcessQueue.child do
              begin
                summary = Piggly::Profile.summary(file)
                pretty  = Piggly::PrettyCompiler.compile(file, Piggly::Profile)

                Piggly::HtmlReporter.output(file, pretty, summary)
              rescue Errno::ENOENT, Piggly::Parser::Failure
              # puts "! #{File.basename file}"
              rescue
                puts "#{$!.class}: #{$!.message}"
                puts $!.backtrace.join("\n")
              end
            end
          end

          Piggly::Util::ProcessQueue.start
        end
      end

    end
  end
end

if __FILE__ == $0
  Piggly::Command.main
end
